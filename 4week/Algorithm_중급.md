<h1> Algorithm 중급</h1>

<h2>
    이차원 리스트
</h2>
<h3>
1. 이차원 리스트
</h3>

> 이차원 리스트는 **리스트를 원소로 가지는 리스트** 
>
> 즉, **행렬(*matrix*)**

```python
matrix = [[1,2,3],[4,5,6],[7,8,9]]

pprint(matrix)
[
    [1,2,3],
    [4,5,6],   
    [7,8,9]
]
```

* 특정 값으로 초기화 된 이차원 리스트 만들기

  1. 직접 작성 (4 x 3 행렬) > 수가 커지면 번거로움

  2. 반복문으로 작성

     ```python
     matrix = []
     for _ in range(M):
         matrix.append([0] * N)
     # 0으로 채워진 MxN 행렬 생성
     ```

  3. 리스트 컴프리헨션으로 작성 (n x m 행렬)

     ```python
     matrix = [[0]*N for _ in range(M)]
     # 0으로 채워진 MxN 행렬 생성
     ```

     > [주의!!] 리스트 컴프리헨션 vs 리스트 곱셈 연산
     >
     > ```python
     > n = 3 # 행
     > m = 3 # 열
     > 
     > matrix1 = [[0] * m for _ in range(n)]
     > matrix2 = [[0] * m] * n 
     > 
     > print(matrix1)
     > print(matrix2)
     > 
     > >>> matrix1 = [[0, 0, 0], [0, 0, 0]]
     > >>> matrix2 = [[0, 0, 0], [0, 0, 0]] # 같아보이지만
     > 
     > # matrix1의 경우: matrix1[0], matrix1[1], matrix1[2]의 인덱스 안에 리스트가 각각 존재
     > # matrix1[0][0]을 바꿨을 때: 해당 인덱스만 1로 변경
     > >>> matrix1 = [[1, 0, 0], [0, 0, 0], [0, 0, 0]]
     > 
     > # matrix2 의 경우: [0, 0, 0] 그 자체가 n (= 3) 만큼 곱해져서 출력
     > # matrix2[0][0] 을 바꿨을 때: [1, 0, 0]으로 변경되고 그 자체가 n만큼 곱해짐
     > # 즉, 전부 다 [1, 0, 0]이 됨
     > >>> matrix2 = [[1, 0, 0], [1, 0, 0], [1, 0, 0]]
     > 
     > # 즉, matrix1 과 matrix2 는 다름
     > # 리스트 컴프리헨션을 사용하자
     > ```

<h3>
    2. 전치
</h3>

> **Transpose** : 행렬의 행과 열을 서로 맞바꾸는 것을 의미

```python
# 원본 행렬
   0  1  2
0 [1, 5, 9]
1 [2, 6, 0]
2 [3, 7, 1]
3 [4, 8, 2]

# 전치한 행렬
   0  1  2  3
0 [1, 2, 3, 4]
1 [5, 6, 7, 8]
2 [9, 0, 1, 2]
```

<h3>
    3. 회전
</h3>

> 이차원 리스트를 오른쪽으로 90도, 180도, 270도(왼쪽으로 90도 돌린 것) 회전하는 경우 존재

---

<h2>
    완전탐색(Exhaustive Search)
</h2>

<h3>
  1. Brute-force  
</h3>

> 모든 경우의 수를 탐색하여 문제를 해결하는 방식

- 가장 단순한 풀이 기법이며, 단순 조건문과 반복문을 이용해서 풀 수 있음
- 복잡한 알고리즘 보다는, 아이디어를 어떻게 코드로 구현할 것인지가 중요
- 효율성은 상대적으로 떨어짐

<h3>
    2. 델타 탐색(Delta Search)
</h3>

> 이차원 리스트의 완전탐색에서 많이 등장하는 유형 = 델타 탐색(상하좌우 탐색)

- (0,0)에서부터 이차원 리스트의 모든 원소를 순회하며 **각 지점에서 상하좌우에 위치한 다른 지점을 조회하거나 이동**하는 방식
- 인덱스(좌표)의 조작을 통해 상하좌우를 탐색
- 행과 열의 변량인 -1, +1 : 델타(Delta)값

---

<h2>
    그래프(Graph)
</h2>

<h3>
    그래프에 대한 이해
</h3>

> 정점과 이를 연결하는 간선들의 집합으로 이루어진 비선형 자료구조

- 소셜 네트워크와 지하철 노선도
- 현실에 있는 개체 간의 관계를 나타내기 위해 사용
- 관련 용어
  - `정점(Vertex)` : 간선으로 연결되는 객체이며, **노드(Node)**라고도 함
  - `간선(Edge)` : 정점 간의 관계(연결)을 표현하는 선을 의미
  - `경로(Path)` : 시작 정점부터 도착 정점까지 거치는 정점을 나열한 것을 의미
  - `인접(Adjacency)` : 두 개의 정점이 하나의 간선으로 **직접 연결**된 상태를 의미
- 종류
  - 무방향 그래프
    - 간선의 **방향이 없는** 가장 일반적인 그래프
    - 간선을 통해 양방향의 정점 이동 가능
    - `차수(Degree)` : 하나의 정점에 연결된 간선의 개수
    - 모든 정점의 차수의 합 = 간선 수 * 2
  - `유방향 그래프`
    - 간선의 **방향이 있는** 그래프
    - 간선의 방향이 가리키는 정점으로 이동 가능
    - 차수(Degree): 진입 차수와 진출 차수로 나누어짐
      - 진입 차수(In-degree) : 외부 정점에서 한 정점으로 들어오는 간선의 수
      - 진출 차수(Out-degree) : 한 정점에서 외부 정점으로 나가는 간선의 수

* 표현
  * 인접 행렬 : 두 정점을 연결하는 **간선이 없으면 0, 있으면 1**을 가지는 **행렬**로 표현하는 방식
    - *무방향 그래프*는 대각선을 기준으로 **대칭**
    - *유방향 그래프*는 대각선을 기준으로 **대칭되지 아니함**
  * 인접 리스트 : 리스트를 통해 각 정점에 대한 인접 정점들을 순차적으로 표현하는 방식
  * 인접 행렬 VS 인접 리스트
    - 인접 행렬은 직관적이고 만들기 편하지만, 불필요하게 공간이 낭비
    - 인접 리스트 는 연결된 정점만 저장하여 효율적이므로 자주 사용

---

<h2>
    깊이우선탐색(DFS) & 넓이우선탐색(BFS)
</h2>

- 그래프 탐색 알고리즘 : 시작 정점에서 간선을 타고 이동할 수 있는 모든 정점을 찾는 알고리즘

  - 깊이우선탐색(DFS)
    - 그래프의 깊이를 우선으로 탐색하기 위해 **스택**의 개념 활용
  - 너비우선탐색(BFS)
    - 그래프의 너비를 우선으로 탐색하기 위해 **큐**의 개념 활용

  ![DFSBFS](C:\Users\Donghyeon Kang\Desktop\TIL\3week\Algorithm_중급.assets\DFSBFS.gif)

<h3>
    깊이 우선 탐색 (Depth First Search)
</h3>

> 시작 정점으로부터 **갈 수 있는 하위 정점까지 가장 깊게 탐색**하고
>
> 제일 끝 하위 정점이라면 **마지막 갈림길(이전 노드)로 돌아와서 다른 정점을 탐색**하며 결국 모든 정점을 방문

- 미로 탈출로 생각한다면 쉽게 이해 가능
  - 한 쪽 길로 깊게 들어갔다가 막히면 다시 돌아와서 다른 길을 탐색

* 특징

  - 모든 정점을 방문 시 유리

  - 경우의 수, 순열과 조합 문제에 많이 사용

  - BFS에 비해 코드 구현이 간단

  - 모든 정점을 방문할 필요가 없거나 최단거리를 구할 때에는 BFS가 유리

1. 탐색을 진행할 그래프가 필요

   - 그래프는 인접 행렬 또는 인접 리스트 방식으로 표현

   - 이미 탐색한 노드는 고려할 대상에서 제외시켜야 한다는 것을 인식할 것

2. 각 정점을 방문했는지 여부를 판별

   - True, False가 아니고 1,0으로 해도 무방, 빈 리스트에 정점을 넣어줘도 됨

     - visted = [False] * N # N은 정점의 개수

     - | 정점 i         | `0`   | `1`   | `2`   | `3`   | `4`   | `5`   | `6`   |
       | -------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
       | visited[**i**] | False | False | False | False | False | False | False |

3. DFS의 사이클

   - 현재 정점 방문처리

     - | 정점 i         | `0`      | `1`   | `2`   | `3`   | `4`   | `5`   |
       | -------------- | -------- | ----- | ----- | ----- | ----- | ----- |
       | visited[**i**] | **True** | False | False | False | False | False |

       예를 들어, visited[0]을 방문한다면 visited[0] = True

     - 이 과정을 끝날 때까지 반복

   - 인접한 모든 정점 확인

   - 방문하지 않은 인접 정점 이동
     - 이 때, 방문하지 않은 인접 정점을 이동하기 위해서는
       - 직전에 방문 했던 정점으로 돌아가야 함을 코드 짤 때 유의할 것

4. DFS 구현방식

   > 인접 리스트로 표현한 그래프를 기준으로 구성
   >
   > ```python
   > # 예시
   > # 코드
   > visited = [False] * N # 방문 처리 리스트 만들기
   > 
   > def dfs(start):
   >   visited[start] = True # 시장 정점 방문 처리
   >   stack = [start] # 돌아갈 곳을 기록
   > 
   >   while len(stack) != 0: # 스택이 빌 때까지(돌아갈 곳이 없을때까지) 반복
   >     current = stack.pop() # 현재 방문 정점(후입선출)
   > 
   >     for adj in graph[current]:
   >       if not visited[adj]:
   >         visited[adj] = True
   >         stack.append(adj)
   > dfs(1)
   > ```
   >
   > 
