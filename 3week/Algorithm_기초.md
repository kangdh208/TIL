<h1> Algorithm 기초</h1>

<h2>
    Algorithm && CodingTest
</h2>

<h4>
    알고리즘
</h4>


> 어떤 *문제*를 해결하기 위해 정해진 일련의 절차나 행동
> *문제*란 Input을 넣었을 때, 원하는 Output이 나오도록 하는 것

<h4>
    코딩테스트
</h4>

> 기업에서 지원자를 대상으로 코딩을 통한 알고리즘 기반 문제 해결 능력을 테스트 하는 것

* 평가사항
  1. 문제해결력
     * 문제 의도를 정확히 파악하고, 적절한 해결 방법을 적용할 수 있는가
  2. 구현력
     * 해결 방법을 프로그래밍을 통해 능숙하게 구현할 수 있는가
* 코딩테스트가 현업 능력을 평가할 수 있을까
  * 코딩테스트 : 문제파악 > 해결 방법 구상 > 정답구현
  * 현업 실무 : 비즈니스 문제 발생 > 해결 방법 구항 > 구현 및 수정
    * 하지만 코딩테스트는 실제 현업 환경과 달리 객체 지향적으로 코드를 작성하지 않으므로 완벽하게 현업 능력을 평가할 수는 없지만 신입의 실력을 어느 정도 측정하는데 좋은 지표가 됨
* 알고리즘 문제 항목
  * 문제이름>난이도>제한및통계>문제내용>입력조건>출력조건>테스트케이스

<h2>
   	데이터 구조 && 알고리즘
</h2>

> 프로그램 = 데이터 구조 + 알고리즘
>
> 데이터 구조 > 데이터를 다양한 방식으로 저장 + 조회, 삽입, 변경, 삭제와 같은 조작 기능 제공

* 데이터 구조 == 데이터 + 구조 : 데이터를 필요에 따라 저장하고 활용할 수 있으므로 문제를 더 효율적으로 풀기 위한 도구가 됨
* 구조를 안다는 것 : 어떻게 저장하고 & 어떻게 활용(조작)할 수 있는지를 안다는 것

> 파이썬의 기본 데이터 구조

* 컨테이너
  * 시퀀스형
    * 리스트         : 가변형(mutable)
    * 튜플             : 불변형(immutable)
    * 레인지         : 불변형(immutable)
  * 비시퀀스형
    * 세트             : 가변형(mutable)
    * 딕셔너리     : 가변형(mutable)

> 코딩테스트의 알고리즘

* 재귀
* 완전탐색
* 시뮬레이션
* 깊이 우선 탐색
* 너비 우선 탐색
* 백트래킹

<h4>
    주요 용어
</h4>

**스크립트 모드**

* 텍스트 에디터를 이용하여 명령어들을 파일에 저장한 후, 파일을 읽어 명령어들을 하나씩 실행할 수 있는 모드

* 코드가 복잡해지면 인터프리트 모드는 번거로우므로 스크립트 모드 사용

  ```html
  이렇게 한 줄씩 입력하다간 손가락이 남아나질 않겠네!!
  ```

**인터프리트 모드**

* 명령어를 한 줄씩 입력하여 실행하는 것은 초보 프로그래머한테 아주 편리한 기능
* 한 줄의 명령어를 입력하여 실행하고 결과를 즉시 알 수 있으며 현재 상태를 언제든 파악 가능
* 하지만 코드가 복잡해지면 인터프리트 모드는 아주 번거롭다.

**소스파일(Source File)**

* 텍스트 에디터를 이용하여 명령어들을 파일에 저장한 후에 파일을 읽어서 명령어들을 하나씩 실행하는 방법이 있으며 이 때 명령어들이 저장된 파일을 소스파일 이라함 

**변수(Variable)**

* 컴퓨터의 메모리 안에 만들어지는 공간

* 숫자나 문자를 저장할 수 있음 >>자료형

* 저장하는 표현은 아래와 같이 왼쪽(변수명) = 오른쪽(변수값-숫자/문자)

  ```python
  var = 11.0
  ```

**식별자(Identifier)**

* 파이썬 객체(변수, 함수, 모듈, 클래스 등)를 식별하는데 사용하는 이름

* 규칙

  * 식별자의 이름은 영문 알파벳, 언더스코어(_), 숫자로 구성

  * 첫 글자에 숫자가 올 수 없음

  * 길이제한이 없고, 대소문자를 구별

  * 다음의 키워드(keywords)는 예약어(reserved words)로 사용할 수 없음

    * ```python
      ['False', 'None', 'True', 'and', 'as', 'assert', 
      'async', 'await', 'break', 'class', 'continue', 
      'def', 'del', 'elif', 'else', 'except', 
      'finally', 'for', 'from', 'global', 'if', 
      'import', 'in', 'is', 'lambda', 'nonlocal', 
      'not', 'or', 'pass', 'raise', 'return', 'try', 
      'while', 'with', 'yield']
      ```

  * 키워드 / 예약어

    * ```python
      import keyword
      print(keyword.kwlist)
      ```
  
  * 내장함수나 모듈 등의 이름으로도 만들면 안됨
  
    * 기존의 이름에 다른 값을 할당하게 되므로 더 이상 동작하지 않음
  

***

<h2>
    자료형 : Type
</h2>
<h4>
    None
</h4>

* 파이썬 자료형 중 하나

* 파이썬에서는 값이 없음을 표현하기 위해 None 타입이 존재함.

* 일반적으로 반환 값이 없는 함수에서 사용하기도 함

  ```python
  print(type(None))
  #<class 'NoneType'>
  a = None
  print(a)
  #None
  ```

<h3>
    숫자형 자료형(Numeric Type)
</h3>

> **산술연산자** *(Arithmetic Operator)* :  기본적인 사칙연산 및 수식 계산

| 연산자 |   내용   |
| :----: | :------: |
|   +    |   덧셈   |
|   -    |   뺄셈   |
|   *    |   곱셈   |
|   /    |  나눗셈  |
|   //   |    몫    |
|   %    |  나머지  |
|   **   | 거듭제곱 |

> **복합연산자** *(In-place Operator)* : 연산과 할당이 이루어짐

| 연산자  |    내용    |
| :-----: | :--------: |
| a += b  | a = a + b  |
| a -= b  | a = a - b  |
| a *= b  | a = a * b  |
| a /= b  | a = a / b  |
| a //= b | a = a // b |
| a %= b  |  a = a %b  |
| a **= b | a = a ** b |

> **비교연산자**  *(Comparison Operator)* : 값을 비교하며, True/ False 값을 리턴함

| 연산자 |            내용             |
| :----: | :-------------------------: |
|   <    |            미만             |
|   <=   |            이하             |
|   >    |            초과             |
|   >=   |            이상             |
|   ==   |            같음             |
|   !=   |          같지않음           |
|   is   |    객체 아이덴티티(OOP)     |
| is not | 객체 아이덴티티가 아닐 경우 |

<h4>
    정수형(Numeric ; integer) : int
</h4>

* 모든 정수의 타입은 int
* Python 3부터는 long 타입은 없고, 모두 int로 표기 됨
* 여타 프로그래밍 언어, Python 2에서는 OS기준 32/64비트
* 매우 큰 수를 나타낼 때 오버플로우가 발생하지 않음
* 오버플로우(overflow) : 데이터 타입별로 사용할 수 있는 메모리의 크기를 넘어서는 상황
* Arbitrary Precision Arithmetic(임의 정밀도 산술)을 통해 고정된 형태의 메모리가 아닌 가용 메모리들을 활용하여 모든 수 표현에 활용

<h4>
    실수형(Numeric ; Floating Point Number) : float
</h4>

* 정수가 아닌 모든 실수는 float 타입

* 부동소수점

  * 실수를 컴퓨터가 표현하는 방법 - 2진수(비트)로 숫자를 표현

  * 이 과정에서 floating point rounding error가 발생하여, 예상치 못한 결과가 발생

    ```python
    11/2 #5.5
    type(10/3) #<class 'float'>
    
    10**100/3  #3.333333333333333e+99
    1/-10**100 #-1e-100
    1e-1       
    ```

* 부동소수점에서 실수 연산 과정에서 발생 가능

  * 값 비교하는 과정에서 정수가 아닌 실수인 경우 주의할 것

    ```python
    3.14 - 3.02 == 0.12
    #False
    #0.120000000000001 != 0.12
    ```

  * 매우 작은 수보다 작은지를 확인하거나 math 모듈 활용
  
    ```python
    # 1. 임의의 작은 수
    abs(a - b) <= 1e-10
    # 2. math 모듈 활용
    import math
    math.isclose(a, b)
    ```

<h4>
    복소수형(Numeric ; Complex Number) : complex
</h4>
* 실수부와 허수부로 구성된 복소수는 모두 complex 타입

  * 허수부를 j로 표현

    ```python
    a = 3+4j
    type(a)
    # <class 'complex'>
    a.real
    # 3.0
    a.imag
    # 4.0
    ```


<h4>
    불린형(Boolean) : Boolean
</h4>

* True / False 값을 가진 타입은 bool 

* 비교/논리 연산을 수행함에 있어서 활용됨

* 다음은 모두 False로 변환

  * 0, 0.0, (), [], {}, '', None

* **bool()함수**

  * 특정 데이터가 `True` 인지 `False`인지 반환

    ```python
    bool(0) #False
    bool(1) #True
    bool(-1) #True
    bool('') #False
    bool([]) #False
    bool([1,2,3]) #True
    ```

* 논리 연산자 (Logical Operator)

  * 논리식을 판단하여  `True` 인지 `False`인지 반환

  * | 연산자  |              내용              |
    | :-----: | :----------------------------: |
    | A and B |     A와 B모두 True시, True     |
    | A or B  |    A와 B모두 False시, False    |
    |   Not   | True를 False로, False를 True로 |

    * and : 모두 참인 경우 참, 그렇지 않으면 거짓

      | 논리연산자 and  | 내용  |
      | :-------------: | ----- |
      |  True and True  | True  |
      | True and False  | False |
      | False and True  | False |
      | False and False | False |

    * or : 둘 중 하나만 참이라도 참, 그렇지 않으면 거짓

      | 논리연산자 or  | 내용  |
      | :------------: | :---: |
      |  True or True  | True  |
      | True or False  | True  |
      | False or True  | True  |
      | False or False | False |

    * not : 참 거짓의 반대의 결과

      | 논리연산자 not | 내용  |
      | :------------: | :---: |
      |    not True    | False |
      |   not False    | True  |


<h3>
    컨테이너
</h3>
* 컨테이너는 여러개의 값을 담을 수 있는 객체
* 서로 다른 자료형을 저장할 수도 있음
* 순서가 있는 데이터(Ordered), 순서가 없는 데이터(Unordered) 로 구분 가능
* 순서가 있다 != 정렬되어 있다 => 주의!


<h4>
    시퀀스형 컨테이너
</h4>
> 문자열(immutable : 문자들의 나열), 리스트(mutable : 변경 가능 값들의 나열), 튜플(immutable : 변경 불가능한 값들의 나열), 레인지(immutable : 숫자들의 나열)

* 시퀀스형 컨테이너의 주요 연산자

  | 연산             | 결과                                                      |
  | ---------------- | --------------------------------------------------------- |
  | s[i]             | s 의 i 번째 항목, 0에서 시작                              |
  | s[i:j]           | s 의 i 에서 j 까지의 슬라이스                             |
  | s[i:j:k]         | s 의 i 에서 j 까지 스텝 k 의 슬라이스                     |
  | s + t            | s 와 t 의 이어 붙이기                                     |
  | s * n 또는 n * s | s 를 그 자신에 n 번 더하는 것                             |
  | x in s           | s 의 항목 중 하나가 x 와 같으면 True, 그렇지 않으면 False |
  | x not in s       | s 의 항목 중 하나가 x 와 같으면 False, 그렇지 않으면 True |
  | len(s)           | s 의 길이                                                 |
  | min(s)           | s 의 가장 작은 항목                                       |
  | max(s)           | s 의 가장 큰 항목                                         |

<h4>
    문자형(String) : str
</h4>

* 큰따옴표(" ")나 작은따옴표('') 안에 들어있는 텍스트 데이터

  * *반드시* 따옴표가 필요
  * 문자열을 묶을 때 동일한 문장부호를 활용
  * `PEP8`에서는 소스코드 내에서 하나의 문장부호를 선택하여 유지하도록 함

* 모든 문자는 `str`타입

>  중첩따옴표(Nested Quotes)
>
> * 따옴표 내에 따옴표 표현할 경우
>
>   >  작은 따옴표 안에는 큰 따옴표로 문자열 생성
>   >
>   > 큰 따옴표 안에는 작은 따옴표로 문자열 생성
>
> 삼중 따옴표(Triple Quotes)
>
> * 작은 따옴표나 큰 따옴표를 삼중으로 사용
>
>   > 따옴표 안에 따옴표를 넣을 때
>   >
>   > 여러줄을 나눠 입력할 때 편리

<h5>
    인덱싱(Indexing)
</h5>

* 인덱스를 통해 특정 값에 접근할 수 있으며 자료를 슬라이싱 할 수 있음

| s     | a    | b    | c    | d    | e    | f    | g    | h    | i    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| index | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| index | -9   | -8   | -7   | -6   | -5   | -4   | -3   | -2   | -1   |

1. s[1] => 'b'
2. s[2:5] => 'cde'
3. s[2:5:2] => 'ce'
4. s[5:2:-1] => 'fed'
5. s[:3] => 'abc'
6. s[5:] => 'fghi'
7. [::] => 전체, s[::-1] => 역순


<h4>
    리스트(list) : lst
</h4>
* 변경 가능한 값들의 나열된 자료형

* 순서를 가지며(ordered), 서로 다른 타입의 요소를 가질 수 있음

* 변경 가능하며(mutable), 반복 가능함(iterable)

* 항상 대괄호 형태로 정의하며, 요소는 콤마로 구분

  * 리스트는 대괄호([]) 혹은 list() 를 통해 생성

  * 순서가 있는 시퀀스로 인덱스를 통해 접근 가능

    * 값에 대한 접근은 list[i]

  * 값 추가는 .append()를 활용하여 추가하고자 하는 값을 전달

    ```python
    even_numbers = [2, 4, 6, 8]
    even_numbers.append(10)
    even_numbers
    # => [2, 4, 6, 8, 10]
    ```

  * 값 삭제는 .pop()을 활용하여 삭제하고자 하는 인덱스를 전달

    ```python
    even_numbers = [2, 4, 6, 8]
    even_numbers.pop(0)
    even_numbers
    # => [4, 6, 8]
    ```
<h4>
    튜플 : tuple
</h4>

* 불변한 값들의 나열
* 순서(ordered)를 가지며, 서로 다른 타입의 요소를 가질 수 있음
* 변경 불가능하며(immutable), 반복 가능함(iterable)
* 항상 소괄호 형태로 정의하며, 요소는 콤마로 구분

  * 소괄호(()) 혹은 tuple()을 통해 생성

    * 값에 대한 접근은 리스트와 동일하게 인덱스로 접근
    * 값 변경은 불가능하여 추가/삭제도 불가능함
<h4>
    레인지 : range
</h4>

* 숫자의 시퀀스를 나타내기 위해 사용
  * 기본형 : range(n)
    * 0부터 n-1까지의 숫자의 시퀀스
  * 범위 지정 : range(n, m)
    * n부터 m-1까지의 숫자의 시퀀스
  * 범위 및 스텝 지정 : range(n, m, s)
    * n부터 m-1까지 s만큼 증가시키며 숫자의 시퀀스
* 변경 불가능하며(immutable), 반복 가능함(iterable)
* range는 숫자의 시퀀스를 나타내기 위해 사용

<h4>
    비시퀀스형 컨테이너
</h4>
> 세트(mutable : 유일한 값들의 모임), 딕셔너리(mutable :키-값들의 모임)


<h4>
    세트 : set
</h4>
* 유일한 값들의 모임(Collection)
* 순서가 없고 중복된 값이 없음
  * 수학에서의 집합과 동일한 구조
* 변경 가능(mutable), 반복가능(iterable)
  * 단, 셋은 순서가 없어 반복의 결과가 정의한 순서와 다를 수 있음
* `중괄호{}` 혹은 `set()`을 통해 생성
* 순서가 없어(unordered) 별도의 값에 접근 불가
* 세트를 활용하면 다른 컨테이너에서 중복된 값을 쉽게 제거할 수 있음
  * 단, 이후 순서가 무시되므로 순서가 중요한 경우 사용할 수 없음
  * 값 추가는 .add()를 활용하여 추가하고자 하는 값을 전달
  * 값 삭제는 .remove()를 활용하여 삭제하고자 하는 값을 전달


<h4>
    딕셔너리 : dic
</h4>

* 키-값(key-value) 쌍으로 이뤄진 모음(collection)

  * 키(key)

    * 불변 자료형만 가능 (리스트, 딕셔너리 등은 불가능함)

  * 값(values)

    * 어떠한 형태든 관계 없음

  * key와 value가 쌍으로 이뤄진 자료구조

    * key는 변경 불가능한 데이터(immutable)만 활용 가능

      * string, integer, float, boolean, tuple, range

    * value는 모든 값으로 설정 가능 (List, Dictionary 등)

* 키와 값은 :로 구분. 개별 요소는 ,로 구분
* 변경 가능하며(mutable), 반복 가능함(iterable)

  * 딕셔너리는 반복하면 키가 반환

* 딕셔너리에 키와 값의 쌍을 추가할 수 있으며, 이미 해당하는 키가 있다면 기존 값이 변경
* 키를 삭제하고자하면 .pop()을 활용하여 삭제하고자 하는 키를 전달
* 키가 없는 경우는 KeyError 발생

***

<h3>
    자료형 변환(Typecasting)
</h3>

* 파이썬에서 데잍 형태는 서로 변환할 수 있음
  * 암시적 형 변환(Implicit)
    * 사용자가 의도하지 않고, 파이썬 내부적으로 자료형을 변환하는 경우
  * 명시적 형 변환(Explicit)
    * 사용자가 특정 함수를 활용하여 의도적으로 자료형을 변환하는 경우

<h4>
    암시적 형 변환(Inplicit Typecasting)
</h4>

* 불린형

*  숫자형(정수, 실수, 복소수)

<h4>
    명시적 형 변환(Explicit Typecasting)
</h4>

* 문자열은 암시적 형 변환이 되지 않음
  * str(형식에 맞는 문자열만 가능), float => int
  * str(형식에 맞는 문자열만 가능), int => float
  * int, float, list, tuple, dict => str

