<h1> Algorithm 기초</h1>

<h2>
    Algorithm && CodingTest
</h2>

<h4>
    알고리즘
</h4>
> 어떤 *문제*를 해결하기 위해 정해진 일련의 절차나 행동
> *문제*란 Input을 넣었을 때, 원하는 Output이 나오도록 하는 것

<h4>
    코딩테스트
</h4>

> 기업에서 지원자를 대상으로 코딩을 통한 알고리즘 기반 문제 해결 능력을 테스트 하는 것

* 평가사항
  1. 문제해결력
     * 문제 의도를 정확히 파악하고, 적절한 해결 방법을 적용할 수 있는가
  2. 구현력
     * 해결 방법을 프로그래밍을 통해 능숙하게 구현할 수 있는가
* 코딩테스트가 현업 능력을 평가할 수 있을까
  * 코딩테스트 : 문제파악 > 해결 방법 구상 > 정답구현
  * 현업 실무 : 비즈니스 문제 발생 > 해결 방법 구항 > 구현 및 수정
    * 하지만 코딩테스트는 실제 현업 환경과 달리 객체 지향적으로 코드를 작성하지 않으므로 완벽하게 현업 능력을 평가할 수는 없지만 신입의 실력을 어느 정도 측정하는데 좋은 지표가 됨
* 알고리즘 문제 항목
  * 문제이름>난이도>제한및통계>문제내용>입력조건>출력조건>테스트케이스

<h2>
   	데이터 구조 && 알고리즘
</h2>

> 프로그램 = 데이터 구조 + 알고리즘
>
> 데이터 구조 > 데이터를 다양한 방식으로 저장 + 조회, 삽입, 변경, 삭제와 같은 조작 기능 제공

* 데이터 구조 == 데이터 + 구조 : 데이터를 필요에 따라 저장하고 활용할 수 있으므로 문제를 더 효율적으로 풀기 위한 도구가 됨
* 구조를 안다는 것 : 어떻게 저장하고 & 어떻게 활용(조작)할 수 있는지를 안다는 것

> 파이썬의 기본 데이터 구조

* 컨테이너
  * 시퀀스형
    * 리스트         : 가변형(mutable)
    * 튜플             : 불변형(immutable)
    * 레인지         : 불변형(immutable)
  * 비시퀀스형
    * 세트             : 가변형(mutable)
    * 딕셔너리     : 가변형(mutable)

> 코딩테스트의 알고리즘

* 재귀

  * 각 원소가 두 가지 선택지를 가질 때 유용하게 사용.
  * 포함이 되면 해당 원소를 넣어 함수를 호출하고, 포함되지 않으면 그 상태에서 함수를 호출하는 등의 식

* 완전탐색

  * 모든 경우의 수를 시도하는 방법
  * Exhaustive search, Brute force
    * 상대적으로 구현이 간단하고, 해가 존재하면 항상 찾게 됨
    * 경우의 수에 따라 실행 시간이 비례하기 때문에 입력 값의 범위가 작은 경우 유용.

* 시뮬레이션

* 깊이 우선 탐색(Depth First Search)

  * 한 루트로 탐색하다가 특정 상황에서 최대한 깊숙이 들어가서 확인한 뒤 다시 돌아가 다른 루트로 탐색하는 방식

* 너비 우선 탐색 (Breadth First Search)

  1. 루트에서 시작한다.
  2. 자식 노드들을 (1)에 저장한다.
  3. (1)에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 (2)에 저장한다.
  4. (2)에 저장된 노드들을 차례로 방문한다. 또한 각각의 자식들을 (3)에 저장한다.
  5. 위의 과정을 반복한다.
  6. 모든 노드를 방문하면 탐색을 마친다.![DFSBFS](C:\Users\Donghyeon Kang\Desktop\TIL\3week\Algorithm_기초.assets\DFSBFS.gif)

  * DFS는 갈림길에서 하나의 길로 들어서서 막다른 길이 나올 때까지 **깊게** 탐색을 하는 것을 볼 수 있음
  * BFS는 갈림길에 연결되어 있는 모든 길을 한번씩 탐색한 뒤 다시 연결되어 있는 모든 길을 **넓게** 탐색하는 것을 볼수 있음.

* 백트래킹

  * 모든 경우의 수를 전부 고려하는 알고리즘
  * 상태공간을 트리로 나타낼 수 있을 때 적합한 방식


<h2>
    시간 복잡도와 빅오 표기법
</h2>

<h3>
    알고리즘의 시간 복잡도
</h3>

> 좋은 알고리즘은  Input을 넣은 후 Output이 나오는 시간이 짧은 알고리즘

개개인의 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정 시간이 다르므로 환경에 영향을 받지 않는 객관적인 기준이 필요함 >> 객관적인 측정을 위해 알고리즘 내부에서 기본연산이 몇 번 일어나는지 확인

* 기본연산 : 단위 시간 1이 소요되는 연산 ex) 할당, 산술, 비교, 반환 …
* 기본연산의 총 횟수 == 알고리즘의 소요 시간
* 기본연산의 횟수를 구하는 것은 환경에 영향을 받지 않는 객관적인 방법이지만, 입력의 개수에 따라 시간이 달라진다는 문제가 있으니 성능을 측정할 때는 입력을 통일시킴
* 가장 기본연산이 많이 일어나는 *최악의 입력 n개*가 들어온다고 가정
* 최악의 입력 n개 : 입력 n개에 따른 소요 시간을 수식으로 세울 수 있음 == **시간 복잡도(Time Complexity)**

<h3>
    시간 복잡도(Time Complextity)
</h3>

> 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는데 걸리는 시간과 입력의 함수 관계

* 단순하게 알고리즘의 수행 시간을 의미한다고
  * 시간 복잡도가 높다 → 느린 알고리즘
  * 시간 복잡도가 낮다 → 빠른 알고리즘

***

<h3>
    빅 오(Big-O) 표기법
</h3>

* 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것

* 최고차항만 남기고 계수와 상수 제거
* 매 입력에 따라 정확한 수식을 구하는 것은 불필요하며 정확한 수치보다는 증가율에 초점을 맞춤

![image-20220802200409812](C:\Users\Donghyeon Kang\Desktop\TIL\3week\Algorithm_기초.assets\image-20220802200409812.png)

* O(1): 단순 산술 계산(덧셈, 뺄셈, 곱셉, 나눗셈) > a + b, 100 * 200
* O(logN): 크기 N인 리스트를 반절씩 순회/탐색 > 이진탐색(Binary Search), 분할정복(Divide & Conquer)
* O(N): 크기 N인 리스트를 순회                            > 리스트 순회, 1중 for 문
* O(NlogN): 크기 N인 리스트를 반절씩 탐색 * 순회 >  높은 성능의 정렬(Merge/Quick/Heap Sort)
* O(N^2): 크기 M, N인 2중 리스트를 순회            >  2중 리스트 순회, 2중 for 문
* O(N^3): 3중 리스트를 순회                                  >  3중 리스트 순회, 3중 for 문
* O(2^N): 크기 N 집합의 부분 집합    
* O(N!): 크기 N 리스트의 순열                          

> 실제 문제에서 어떻게 적용시키나

* 실제 문제는 “초” 단위로 제한 시간(제약 조건)이 주어지고 시간 복잡도도 정확하게 예측하기가 어려움
* 따라서 어림짐작을 하는 방법을 알아야 하며, 보통 1초에 1억 번 연산으로 계산을 하고 입력의 개수에 따라 반복문을 몇 중으로 순회할 수 있는지 파악해야 함
  * (일반적인 상황에서) 1초가 걸리는 입력의 크기
    * O(N): 1억 (기준)
    * O(NlogN): 500만
    * O(N^2): 1만
    * O(N^3): 500
    * O(2^N):20
    * O(N!): 10
* 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 성능이 달라질 수 있고 시험에서 정답 여부가 갈리는 포인트가 된다는 것

**내장 함수, 메서드의 시간 복잡도도 확인할 필요가 있음**

* 가끔 for문을 1번만 썼는데 왜 시간초과가 날 수 있음

* for문이 1번이라고 해서 무조건 O(n)인 것은 아님
* for문 안에 O(n)의 내장 함수를 사용했다면 사실상 이중 for문과 다를 것이 없기 때문

![image-20220802201338202](C:\Users\Donghyeon Kang\Desktop\TIL\3week\Algorithm_기초.assets\image-20220802201338202.png)





